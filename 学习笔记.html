<html>
<head>
  <title>Evernote Export</title>
  <basefont face="微软雅黑" size="2" />
  <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
  <meta name="exporter-version" content="YXBJ Windows/605495 (zh-CN, DDL); Windows/10.0.0 (Win64); EDAMVersion=V2;"/>
  <style>
    body, td {
      font-family: 微软雅黑;
      font-size: 10pt;
    }
  </style>
</head>
<body>
<a name="506"/>

<div>
<span><div><br/></div><div>request.setCharacterEncoding(&quot;utf-8&quot;)：是针对请求体编码的转换，而get请求请求体为空，所以对get请求无效。但Tomcat在8.0以后的版本解决了get请求的中文乱码问题，所以可以自行解决。</div><div><br/></div><div>get与post都是基于tcp/ip产生的，结构上是相同的，都有请求行，请求头，空白行，请求体。技术上两者可以相同用法，但是在约定中get将参数添加到url后面，空置请求体，post将参数放到请求体中。将get请求的长度限制在2k。get请求会产生1个tcp数据包，将header与data一起发送，服务器相应200。而post会产生2个TCP数据包，先发送header，服务器相应100 （continue）再发送data，但并不是所有浏览器都会分开发送，如Firefox。</div><div>        虽然post比get更安全，但http协议本身是不加密的，所以都是明文传输，如果被抓包，都不安全。所以出现了https，http先与SSL通信，SSL再与TCP通信，使用了隧道进行通信。</div><div><br/></div><div>ACID关系型数据库事务特性：</div><div>    原子性、一致性、隔离性、持久性</div><div>CAP是非关系型数据库追求特性：</div><div>    强一致性、可用性、分区容错性</div><div><br/></div><div>设计UV量20W秒，并发低于100</div><div>服务器配置共18台服务器</div><div>    nginx：3</div><div>    redis：3</div><div>    mysql：2</div><div><br/></div><div>难点：当初为了解决超卖问题，将【剩余可投金额-投资金额&gt;0】加入where判断，但是当条件不成立时，sql语句不会执行也不会报错回滚，导致用户减钱但没投资成功，使用手动new错误抛出，但设计不规范，后来改成了判断sql语句没执行，就手动回滚</div><div>    </div><div>人员：共12</div><div>UI：2</div><div>前端：3</div><div>后端：4</div><div>项目经理兼TL：1</div><div>测试：2</div><div>    </div><div><br/></div><div>mysql并发数量：500</div><div>tomcat并发数量：1000</div><div><br/></div><div>数据库语句：</div><div>    创建表：CREATE TABLE MM (id int NOT NULL,name char(10) NOT NULL,age char(2)，sex, DEFAULT '',PRIMARY KEY (id));</div><div>    移除表：DROP DATABASE 数据库名;</div><div>    增添数据：insert into CW (id,name,age,sex) values(1,'张三',20,'男')</div><div>    更改数据：UPDATE CW SET name='李小龙' WHERE id=3;</div><div>    删除数据：DELETE FROM CW WHERE id=6;</div><div>    更改表结构：ALTER TABLE 表名 CHANGE 旧列名 新列名 数据类型 [unique key];</div><div><br/></div><div>linux常用命令：</div><div><span>    </span>poweroff：<br/></div><div><span>    </span>pwd：<br/></div><div><span>    </span>cd：<br/></div><div><span>    </span>tar -zxvf：<br/></div><div><span>    vi：</span><br/></div><div>    </div><div><br/></div><div><br/></div><div><span style="color: rgb(227, 0, 0);">IO与NIO</span>：</div><div>    IO：</div><div>        阻塞式IO，代码会阻塞住，直到有内容可供读取</div><div>        面向流</div><div>    NIO：</div><div>        selector是注册各种I/O事件的地方，监听channel管道发生感兴趣的行为如读或写，通过selectorkey得到信息，就会进行通知进行操作，本质是延迟IO行为的发生，到真正需要IO时才会组执行。</div><div>        面向缓冲区</div><div>        核心三组件：</div><div>            channel：通道，和IO中的流差不多，不过流是单向的，channel是双向的，既能写又能读，主要实现有FileChannel，DatagramChannel，SocketChannel和ServerSocketChannel。channel不关心文件物理结构，可以是文件也可以是socket。</div><div>                FileChannel无法直接创建，需要通过InputStream、outputStream或RandomAccessFile进行获取实例。</div><div>            Buffer：缓冲区，channel是面对缓冲区的，无论是读写都套使用缓冲区</div><div>            Selector：选择器，运行单线程处理多个channel，</div><div>web:</div><div>    三大组件：servlet ，filter ， listener。监听器监听三大域的生命周期与存储变化</div><div>    加载顺序：listener , filter , servlet </div><div>    L与F服务器启动时就加载，servlet第一次请求时，servlet容器会对其进行加载，创建request与response对象后交给servlet，默认懒汉式启动。</div><div><br/></div><div><span style="color: rgb(227, 0, 0);">mybatis</span>：基于ORM思想（半ORM）封装了JDBC，对象关系映射，类属性与数据库字段一一对应</div><div>    1、导包</div><div>        mysql-connention-java：连接的是mysql数据库</div><div>        mybatis：mybatis依赖</div><div>    2、配置文件</div><div>        在resources文件夹下创建mybatis.xml配置文件</div><div>        给xml文件添加配置文件约束，数据源配置文件、数据源、sqlSession工厂，sqlsession生成mapper</div><div>        &lt;environment/&gt;添加连接数据库&lt;dataSource/&gt;，采用jdbc链接，也可以采用数据库连接池</div><div>        创建mapper文件，添加mapper文件约束</div><div>        将mapper文件加入到配置文件中</div><div>    3、常用注解</div><div>        @MapperScan(&quot;com.tian.mybatis.mapper&quot;)：为了集成spring而产生的注解，扫描mapper文件，开启省略@Mapper注解。</div><div>        @Mapper：标识这是一个mapper接口，默认不可省略。作用在dao层接口，使得其生成代理对象bean，交给spring 容器管理。</div><div>        @select：方法级别的sql查询</div><div><br/></div><div>    使用动态代理模式可以降低使用难度:</div><div>        创建mapper配置文件同时创建同文件名接口类，mapper文件的namespace值等于接口全名，文件里的方法名必须相同。</div><div><br/></div><div>    maven要求配置文件要放入resource目录下，否则不会打包走，为了方便mapper与接口类一一对应，mybatis提供资源扫描器</div><div>        pom文件》build》resources》resource</div><div><br/></div><div>    使用注解方式是现在的主流方式。</div><div>        </div><div>    SqlSessionFactory：懒汉式单例设计，sqlSession工厂。sqlsession是需要关闭的资源</div><div>        </div><div>    中#{ }与${ }的区别：</div><div>        #{ }是预编译对象，比较安全，无论是传入对象、多个参数、单个参数int，string都可以</div><div>        ${ }是操作对象，拼接方式会被注入攻击，传入对象或多个参数是没问题，但传入单个参数时(int)会被当成Integer对象，需要用value占位</div><div><br/></div><div>    mybatis缓存机制：为了减少和数据库的交互次数。</div><div>        一级缓存：一级缓存作用域是sqlsession级别的，同一个sqlsession中执行相同的sql查询（相同的sql和参数），第一次会去查询数据库并写到缓存中，第二次从一级缓存中取。一级缓存无过期时间，只有生命周期。</div><div>            一级缓存时执行commit，close，增删改等操作，就会清空当前的一级缓存；当对SqlSession执行更新操作（update、delete、insert）后并执行commit时，会连同二级缓存一起清理</div><div><br/></div><div><br/></div><div><br/></div><div>        二级缓存：它指的是Mybatis中SqlSessionFactory对象的缓存。由同一个SqlSessionFactory对象创建的SqlSession共享其缓存。</div><div><span style="font-size: unset; color: unset; font-family: unset;">            二级缓存是 mapper 映射级别的缓存，多个 SqlSession 去操作同一个 Mapper 映射的 sql 语句，多个SqlSession 可以共用二级缓存，二级缓存是跨 SqlSession 的。</span></div><div>            在关闭sqlsession后(close)，才会把该sqlsession一级缓存中的数据添加到namespace的二级缓存中。</div><div>            开启了二级缓存后，还需要将要缓存的pojo实现Serializable接口，为了将缓存数据取出执行反序列化操作，因为二级缓存数据存储介质多种多样，不一定只存在内存中，有可能存在硬盘中。</div><div>            每当存取数据的时候，都有检测一下cache的生命时间，默认是1小时，如果这个cache存活了一个小时，那么将整个清空一下</div><div><br/></div><div>    解决数据库与实体类属性名不同，或解决多表联查，需要创建字段映射表。</div><div><br/></div><div>        当 Mybatis 调用 Dao 层查询数据库时，先查询二级缓存，二级缓存中无对应数据，再去查询一级缓存，一级缓存中也没有，最后去数据库查找。</div><div><br/></div><div>    mybatis分页：pagehelper，limit</div><div>        </div><div><br/></div><div>    <span style="color: rgb(214, 214, 214);">注解：</span></div><div><span style="color: rgb(214, 214, 214);">        @webServlet：注解这个类是servlet，参数：name：别名，一般不写  value：请求路径，等同urlPatterns</span></div><div><span style="color: rgb(214, 214, 214);">        @webFilter   ： value：过滤路径</span></div><div><span style="color: rgb(214, 214, 214);">        @webListener：不需要写参数 </span></div><div><br/></div><div><br/></div><div><span style="font-size: 12pt; color: rgb(227, 0, 0);">springMVC </span>：封装了servlet的控制器层框架。spring3.0以后的产物</div><div>    前端控制器、处理器映射器、处理器适配器、处理器、视图解析器，web.mxl版本要高于3.0</div><div><span style="font-size: unset; color: unset; font-family: unset;">    1、导包：创建web工程，maven创建web工程指创建webapp文件夹，需要手动创建Java，resource文件夹。</span></div><div><span style="font-size: unset; color: unset; font-family: unset;">        javax.servlet-api：一般仅开发环境即可。部分tomcat没有servlet的api</span></div><div><span style="font-size: unset; color: unset; font-family: unset;">        spring-webmvc：通过依赖传递导入一连串包</span></div><div>    2、配置文件：</div><div>        在web.xml文件中配置好前端控制器 ，并添加DispatcherServlet类地址位置，设置第一时间启动。</div><div>        在resources中创建配置文件，配置文件中将处理器映射器，处理器适配器，视图解析器的类交给了bean容器。</div><div>        配置servlet-mapping，将请求路径交给前端控制器。会根据路径映射配置导致静态资源被拦截。</div><div>            tomcat只能识别动态资源，需要配置default处理器，将静态资源路径拦截给default。或使用&lt;mvc:resources mapping=&quot;&quot;/&gt;声明为静态资源。</div><div>        contextConfigLocation：配置文件的本地地址，起点指向resource中的位置。将三个类交给spring生成bean对象</div><div>        注解版：</div><div>        在resources文件中配置&lt;mvc:annotation-driven/&gt;自动加载注解版</div><div>        &lt;context:component-scan base-package=&quot;&quot;/&gt;：扫描路径下所有带@controller注解的类</div><div><br/></div><div>    3、常用注解</div><div>        @Controller：标识当前类是处理器类，会被bean扫描，并加入spring容器</div><div>        @RequestMapping：请求映射路径，参数method可以更改请求的方式, param 指定必须携带该名称的参数</div><div>        @RequestBody：接收json数据</div><div>        @ResponseBody：返回json数据，key-value形式，如对象，存储键值对的集合如存放对象的List</div><div>        @RestController：相当于类中的所有方法都添加了ResponseBody注解</div><div>        @PathVariable：使用restfull风格请求，从路径中取到参数，路径占位符用{path}</div><div>        @GetMapping：get请求路径</div><div>        @PostMapping：post请求路径</div><div>        @RequestParam：将不同名的参数绑定给方法 ，request=false,可以不必须有这个参数</div><div><br/></div><div>    处理器适配器会读取工程中所有对象，使用无参构造器创建对象，注意application不可手动创建。给处理器提供所需要的对象。</div><div><br/></div><div>    ModelAndView是springMVC提供的一个对象，可以放模型或视图</div><div>        mav.addObject()重定向时相当于request域对象，键值对格式。重定向时会在url中传递。</div><div>        mav.setViewName()传入页面路径，会跳转到指定路径</div><div>        默认请求转发。需要明确根路径。</div><div>    返回String类型更广泛：</div><div>        返回为路径字符串时，会跳转到指定路径，默认的是请求转发，“sendredirect:/path&quot;重定向，需要明确根路径</div><div>        可以适配器传入model对象来代替mav，在域中存放信息。</div><div>        </div><div>    springMVC与jackson:</div><div>    1、导包：</div><div>        jackson-core：</div><div>        jackson-databind：</div><div><br/></div><div>        springmvc提供了中文乱码过滤器CharacterEncodingFilter，将其配置入web.xml中并添加character参数即可。/*过滤所有请求</div><div><span style="font-size: unset;"><br/></span></div><div><span style="font-size: unset;"><br/></span></div><div><span style="font-size: unset; color: unset; font-family: unset;">    拦截器：请求到达前端控制器，但还没到达处理器</span>，响应结果也会被拦截。可以拦截未登录的用户</div><div><span style="font-size: unset; color: unset; font-family: unset;">        实现HandleInterceptor接口，重写三个方法。</span></div><div>        preHandle：请求到达处理器之前，方法会判断是否return true放行。</div><div>        postHandle：在处理器处理完毕，回值给前端控制器，但还没到前端控制器时进行拦截。</div><div>        afterComletion：响应结束了，留给进行资源关闭的时机，之后销毁当前拦截器</div><div>        拦截路径：</div><div>            在springMVC配置文件中配置，</div><div>                &lt;mvc:interceptor&gt;</div><div>                    &lt;mvc:mapping path=&quot;&quot;/&gt;拦截路径/**，**代表着多层路径</div><div>                    &lt;bean class=&quot;&quot;/&gt;：拦截器类</div><div><br/></div><div><br/></div><div>    为保证页面安全，禁止直接访问页面，需要对服务器进行请求，服务器在内部进行<span style="color: rgb(255, 0, 0);">转发访问</span>，防止对页面虚假注入数据，将页面放入webapp/META-INF中，这个文件夹是禁止请求访问的，同时为了减少书写，配置解析器，提供访问的前缀后缀。</div><div>        在springMVC配置文件中手动配置视图解析器，将InternalResourceViewResolver类加入bean，所有转发访问会自动拼接。</div><div>        &lt;property name=&quot;prefix&quot; value=&quot;&quot;&gt;：配置前缀 </div><div>        &lt;property name=&quot;suffix&quot; value=&quot;&quot;&gt;：配置前后缀</div><div><br/></div><div><br/></div><div>文件上传：导入fileupload，io包，前端页面需要是muti，配置文件上传解析器CommonsMultipartResolver，并添加size，使用的是字节流，旧版本encoding是为了兼顾非文本的文件上传。</div><div>在处理器中向处理器适配器要mutipartfile，通过mutipartfil.transferTo到文件中。</div><div><br/></div><div><br/></div><div><br/></div><div><span style="font-size: 12pt; color: rgb(227, 0, 0);">spring</span>：对整个工程对象的管理与封装，管理所有框架</div><div>        面向对象的思想发展出来的，两大核心ioc、aop，解耦合。</div><div>        <span style="color: rgb(255, 0, 0);">ioc</span>：控制反转，DI依赖注入是实现IOC的方式之一，两者并不相等</div><div>        spring容器使用无参构造函数创建对象，再使用get,set方法给属性赋值。</div><div><span style="font-size: unset; color: unset; font-family: unset;">    1、导包：</span></div><div>        spring-context：通过依赖传递导入其它包</div><div>    2、配置文件</div><div>        resources文件夹中创建applicationContext.xml，将需要被容器管理的类加入到&lt;bean/&gt;</div><div>        获取ioc容器：ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;)</div><div>        通过容器获取对象:ioc.getBean(&quot;id&quot;)，通过反射机制，默认使用无参构造创建对象</div><div>    </div><div>        注解版：&lt;context:component-scan base-package=&quot;&quot;/&gt;扫描指定包的注解</div><div>    3、常用注解</div><div>        @AutoWrite：默认bytype方式注入，配合@Qualifier(value=&quot;&quot;)进行byname注入</div><div>        @Resource是javax中的一个注入功能的注解，比@AutoWrite功能更强大，但是效率低，默认是byname注入，但是没找到还可以bytype方式注入。</div><div>      </div><div>        @Component：将普通类交给spring容器管理 ，不添加唯一标识时，再bean容器中默认name是类的小驼峰式</div><div>        @Repository：将普通类交给spring容器管理 、主dao层</div><div>        @Service：将普通类交给spring容器管理 、主service层</div><div>        @Controller：将普通类交给spring容器管理 、主控制层</div><div>        @Qualifier(value=&quot;&quot;)：指定具体注入哪个类</div><div>        @scop：作用域</div><div>        @Configuration：配置类，是一个Component</div><div>        @ComponentScan：扫描包配置</div><div>        @Bean：与@Configuration配合使用，相当于&lt;bean&gt;，方法名是id，返回值是要返回的class类型</div><div>        @import：引入另一个config类，同时生效</div><div><br/></div><div>    spring 容器启动三种方式</div><div>        new ClassPathXmlApplicationContext(xml);</div><div>        new FileSystemXmlApplicationContext(xml);</div><div>    </div><div>        <span style="color: rgb(255, 0, 0);">aop</span>面向对象的进一步延申，目标类和增强类需要被容器管理</div><div>        本质是动态代理，对原对象进行了增强，默认是jdk方式invocationHandler接口</div><div>        术语：</div><div>            切面：aspect即增强方法    </div><div>            连接点：joinPoint    </div><div>            切入点：pointcut    </div><div>            目标对象：target    </div><div>            通知：advice</div><div>        通知时机：before 、after 、around</div><div>        关于aop，虽然spring实现了，但是不如AspectJ简洁，也不支持注解，所以spring将AspectJ引入到了框架中。spring中使用aop一般使用AspectJ实现 ，底层使用cglib动态代理</div><div>        1、导包</div><div>        spring-aspects：AspectJ包</div><div>       2、 配置文件</div><div>        applicationContext.xml：</div><div>        &lt;aop:config&gt;配置切面</div><div>        &lt;aop:aspect   ref=&quot;加入到bean中的增强类&quot;&gt;指向增强类</div><div>        &lt;aop:pointcut id=&quot;切点起的唯一标识&quot; expression=&quot;切点的位置&quot;/&gt;通过表达式匹配切点位置</div><div>        &lt;aop:befor method=&quot;增强类中的方法&quot; pointcut-ref=&quot;切点唯一标识&quot;&gt;增强类的方法，切点位置</div><div>        开启切面注解</div><div>        &lt;aop:aspectJ-autoproxy/&gt;</div><div>        在增强类上注解@Aspect  </div><div>            1、在增强类中创建无参无返回的空方法，切点名即为方法名。</div><div>                @PointCut(&quot;execution(规则 )&quot;)</div><div>                在增强方法上添加注解</div><div>                @before(&quot;切点名&quot;)：触发时机</div><div><br/></div><div>spring整合mybatis</div><div><span style="font-size: unset; color: unset; font-family: unset;">    1、导包：</span></div><div><span style="font-size: unset; color: unset; font-family: unset;">        mybatis-spring</span></div><div>        不使用数据库连接池时，需要导入spring-jdbc包</div><div>        druid：使用数据库连接池链接</div><div>    2、配置文件：</div><div>        application读取数据源参数的配置文件    可以没有</div><div>        application配置数据源  </div><div>            &lt;bean id=&quot;dataSource&quot; class=&quot;DriverManagerDataSource&quot;&gt;    ：直连版，property添加四个参数</div><div>            &lt;bean id=&quot;dataSource&quot; class=&quot;DriverManagerDataSource&quot;&gt;    ：数据库连接池版，额外写MaxActive，initialsize</div><div>        sqlSessionFactory工厂</div><div>            &lt;bean id=&quot;sqlSessionFactory&quot; class=&quot;SqlSessionFactoryBean&quot;&gt; 配置datasource属性   </div><div>            </div><div>        根据工程生成的sqlSession  生成mapper扫描器 ，spring提供的，加载多有mapper接口和xml文件，动态代理生成接口的实现类，放在spring容器中</div><div>            &lt;bean id=&quot;mapperScanner&quot; class=&quot; MapperScannerConfigurer&quot;&gt;，配置sqlSessionFactoryBeanName，basePackage属性</div><div>        spring的注解扫描</div><div><br/></div><div>spring事务：spring提供完整的事务体系，是对jdbc事务的进一步封装，需要用aop来操作</div><div>    1、导包：</div><div>        spring-jdbc</div><div>        spring-tx</div><div>    spring事务支持有7中级别，常用propagation_REquired：支持当前事务，若当前没有事务，新建事务</div><div>    2、配置文件</div><div>        &lt;bean id=&quot;&quot; class=&quot;DataSourcesTransactionManager&quot;/&gt;：把事务交给spring容器，配置dataSource属性</div><div>        &lt;aop:config&gt;</div><div>            &lt;aop:pointcut id=&quot;&quot; expression=&quot;&quot;/&gt;切点</div><div>            &lt;aop:advisor advice-ref=&quot;&quot; pointcut-ref=&quot;&quot;/&gt;通知器</div><div>        复制&lt;tx:advice/&gt;配置</div><div><br/></div><div><br/></div><div><br/></div><div><span style="color: rgb(227, 0, 0);">redis</span>:一款基于内存的，可持久化的日志型key-value数据库</div><div>    key固定为String类型，value支持5种基本类型</div><div>        String：字符串，是二进制安全的，可以存储图片或序列话的对象，最大存储值为512M</div><div>            指令：set key value , get key value</div><div>        Hash：哈希，存储的值本身又是k-v结构</div><div>            指令：hset key field fieldValue ， hget key field</div><div>        List：列表，有序可重复的多个字符串</div><div>            指令：lpush key value...：从左侧依次插入，rpush key value...：从右侧插入，lrange key start end ：读取区间内的元素，llen key：查询列表长度</div><div>        Set：集合，无序不可重复的集合</div><div>            指令：sadd key member [member…] ，smembers key</div><div>        zset：有序集合，不可重复但会进行打分排序</div><div>            指令：zadd key score member [score member…]</div><div><br/></div><div>    redis事务：redis的事务是运用了事务的思想的一组命令的集合，没有回滚的概念，严格上而言，没有事务功能。在事务失败时会继续执行余下命令</div><div>    </div><div>        multi：标记事务的开始，将事务内的多条命令放入队列中</div><div>        exec：执行队列中的所有命令，被打断会返回nil</div><div>        <span style="font-size: 10.5pt; color: rgb(0, 0, 0); font-family: Calibri;-en-paragraph:true;">discard：</span><span style="-en-paragraph:true;"><span style="font-size: 10pt; color: rgb(0, 0, 0); font-family: Calibri;">取消事务，放弃执行队列中的所有命令</span></span></div><div><span style="font-size: 10.5pt; font-family: Calibri;-en-paragraph:true;">          </span><span style="font-size: 11pt; color: unset; font-family: Calibri;">watch key：监控一个或多个key，如果事务执行期间，key的值被其它命令改动，事务将被打断</span></div><div><span style="font-size: 11pt; color: unset; font-family: Calibri;">          </span><span style="font-size: 11pt; font-family: Calibri;">unwatch：结束监控所有key，如果事务已执行或已取消，则不需要再写监控</span></div><div><span style="font-size: 11pt; font-family: Calibri;">    </span></div><div><span style="font-size: 11pt; font-family: Calibri;"> </span> <span style="font-size: 11pt;"> </span> <span style="font-size: 10pt;">持久化</span><span style="font-size: 10pt;">：</span></div><div><span style="font-size: 10pt;">        1、RDB快照，在指定时间间隔内将数据下入磁盘，保存数据是单独的进程，不影响redis使用</span></div><div><span style="font-size: 10pt;">            缺点：会丢失最后一次备份之后的数据，数据库很大的话，会占用较多时间，毫秒级，甚至是一秒。</span></div><div><span style="font-size: 10pt;">        2、AOF回放，每接收一次更改操作，都会写入AOF文件中，重启时执行AOF文件中的命令</span></div><div><span style="font-size: 10pt;">            缺点：AOF文件会越来越大</span></div><div><font style="font-size: 10pt;"><br/></font></div><div><span style="font-size: 10pt;">    主从复制-读写分离：</span></div><div><span style="font-size: 10pt;">        master负责写，同时将数据同步到从，slave负责读，当主挂掉后，将其中一台从手动提升为主</span></div><div><span style="font-size: 10pt;">    高可用：</span></div><div><span style="font-size: 10pt;">        哨兵机制，会自动检测主服务器是否挂掉，并自动提升从服务器为主服务器</span></div><div><span style="font-size: 11pt; font-family: Calibri;">    </span></div><div>    redis实现分布式锁：一种设计思路，创建成功即为获得锁。</div><div>        setnx key value ：如果key不存在，则创建，如果key存在，则放弃。创建成功即为获得锁，给数据加上过期时间，避免数据越来越多和造成死锁。</div><div>        </div><div><br/></div><div><span style="color: rgb(227, 0, 0);">dubbo</span>：分布式系统，RPC远程过程调用与服务治理框架，进程间通信方式，默认端口20880</div><div>    1、导包</div><div>        dubbo</div><div>    2、设置与注解</div><div>        &lt;dubbo:protocol name=&quot;dubbo&quot; port=&quot;20880&quot;/&gt;：spring配置文件，远程调用选择dubbo协议，端口20880</div><div>        &lt;dubbo:application name=&quot;&quot;/&gt;：给当前模块命名</div><div>        &lt;dubbo:service interface=&quot;&quot; ref=&quot;&quot; registry=&quot;N/A&quot;/&gt;：生产者暴露服务，ref实际实现类，直接连接</div><div>        &lt;dubbo:reference id=&quot;&quot; interface=&quot;&quot; url=&quot;dubbo://&quot; registry=&quot;N/A&quot; /&gt;：消费者关联远程服务，生成代理bean对象</div><div>        &lt;bean id=&quot;&quot; class=&quot;&quot;/&gt;实际实现类注册入bean</div><div>        </div><div>        &lt;dubbo:registry address=&quot;zookeeper://&quot;/&gt;：添加注册中心，直连标签中取消地址和register属性。</div><div><br/></div><div>        消费者需要将生产者安装到本地仓库</div><div>    分包，每个服务尽可能大力度，每个服务应代表一个功能而不是某功能中的一个部分</div><div>        </div><div>    Dubbo中常用标签。分为三个类别：公用标签，服务提供者标签，服务消费者标签</div><div>        注解</div><div>        在入口类添加注解@EnableDubboConfiguration</div><div>        @Service(interfaceClass = LoanInfoService.class ,version = &quot;1.0.0&quot; , timeout = 20000)：作为服务者暴露出去</div><div>        @reference(interfaceClass = LoanInfoService.class ,version = &quot;1.0.0&quot; , timeout = 20000,check = false , retries = 2)</div><div>        </div><div><br/></div><div><span style="color: rgb(227, 0, 0);">Zookeeper</span>：注册中心，高性能的，分布式的，开放源码的分布式应用程序协调服务。需要安装程序。</div><div>    1、导包</div><div>        curator-framework：消费者和生产者导入zookeeper客户端依赖，</div><div>    2、设置与注解</div><div><br/></div><div>    高可用：</div><div>        zookeeper是高可用的，当zookeeper宕机，消费者可以从本地缓存下来的服务地址中进行访问</div><div><br/></div><div><br/></div><div><span style="color: rgb(227, 0, 0);">springboot</span> :是一个集成型框架，不是技术框架，简化了配置，采用了大量默认配置。</div><div>能用Java main方法启动内嵌的Tomcat服务器运行程序，不需要war包</div><div>    1、导包：</div><div>        spring-boot-starter-parent：spring boot工程必须继承这个父</div><div>        spring-boot-starter-web：当前是web工程，添加web工程起步依赖</div><div>        </div><div>    2、配置文件</div><div>        springboot选择了properties作为配置文件，配置文件中有着默认配置，</div><div>        spring配置文件可以有多个格式，application名称会优先起效，spring:profiles:active：dev可以指定最终启用某个-dev版本。</div><div>        server.port:8080;服务端口</div><div>        server.servlet.context-path:站点名称</div><div><br/></div><div>    3、常用注解</div><div>        @SpringfBootfApplication：表明是一个springboot工程与SpringApplication.run(class,args); 一起用</div><div>        @Value：读取配置文件中自定义的配置，例@Value(&quot;$Student.name&quot;)</div><div>        @ConfigurationProperties(prefix = &quot;school&quot;)：当自定义配置太多时，可以创建对应实体类，通过配置该注解</div><div>进行读取到类中。交给bean容器管理再将该类注入到需要的地方。</div><div>        强制编译xml文件</div><div>spring不推荐使用xml文件，可以使用properties文件</div><div><br/></div><div><br/></div><div><span style="color: rgb(30, 204, 255);">Springboot与jsp</span>：</div><div>    不推荐使用jsp技术:</div><div>    添加tomcat-embed-jasper包对jsp解析</div><div>    spring.mvc.view.prefix=/：为视图解析器添加前缀/代表src/main/webapp</div><div>    如果要使用jsp文件，必须添加至webapp,并在项目结构中添加web Resource Directory指向webapp目录，强制spring编译该目录到WETA-INF/resources，</div><div><br/></div><div><br/></div><div><span style="color: rgb(30, 204, 255);">springboot与mybatis</span>:</div><div>        是mybatis主动加入springboot。</div><div>    1、导包：</div><div>        mybatis-spring-boot-starter</div><div>    2、配置文件：</div><div>        spring.datasource.    ：配置数据库信息</div><div>        springboot要求配置文件放在resources文件夹下，与mybatis冲突，所以要在pom中指定编译目标文件夹下的mapper映射文件，</div><div>        或将mapper.xml文件放置resources文件下，并指定mybatis编译后的映射文件路径mybatis.mapper-locations = classpath:</div><div><br/></div><div>    3、事务：使用的是spring本身提供的事务管理，在入口类添加注解@EnableTransactionManagement开启事务管理spring2.x之后可以不加，在service方法上添加注解@Transactional即可开启自动托管机制</div><div><br/></div><div><br/></div><div><span style="color: rgb(30, 204, 255);">springboot与redis</span>:</div><div>    1、导包：</div><div>        spring-boot-start-redis：使用redis作为缓存，降低数据库压力。</div><div>    2、配置文件</div><div>        spring.redis.：配置redis数据库信息</div><div>    3、使用</div><div>        1、注入redisTemplate   </div><div>        2、将key键序列化 redisTemplate.setKeySerializer(new StringRedisSerializer())   </div><div>        3、redisTemplate.opsForValue().get(&quot;&quot;)取数据    </div><div>        3、redisTemplate.opsForValue().set(key,value,timeOut,TimeUtil)存有时长限制的数据 </div><div><br/></div><div><br/></div><div><span style="color: rgb(255, 70, 53);">线程池</span>：</div><div>        jdk自带线程池技术，使用Executors工具类，根据实际需求调用方法创建线程池，一般会根据CPU核心数*2创建线程数量，向创建好的线程池中submit提交runnable的实现类。</div><div>        线程池核心参数</div><div>            corePoolSize：核心线程数</div><div>            maximumPoolSize：最大线程数</div><div>            keepAliveTime：最大空闲时间</div><div>            unit：时间单位</div><div>            workQueue：阻塞队列</div><div>            threadFactory：线程工厂</div><div>            handler：拒绝策略</div><div><br/></div><div><br/></div><div><span style="color: rgb(30, 204, 255);">Springboot与dubbo</span>：</div><div>        dubbo主动集成入springboot，</div><div>    1、导包：</div><div>        dubbo-spring-boot-starter</div><div>        zkclient：注册中心</div><div>    2 、配置文件：</div><div>        spring.application.name：服务提供者应用名称</div><div>        spring.dubbo.server=true：表示是服务提供者</div><div>        spring.dubbo.registry=zookeeper://：注册中心地址</div><div>    3、注解</div><div>        在入口类添加注解@EnableDubboConfiguration</div><div>        @Service(interfaceClass = LoanInfoService.class ,version = &quot;1.0.0&quot; , timeout = 20000)：在服务提供者实现类上添加注解</div><div>        @Reference(interfaceClass = LoanInfoService.class ,version = &quot;1.0.0&quot; , timeout = 20000,check = false , retries = 2)：消费者上添加，调用远程代理bean对象</div><div><br/></div><div><br/></div><div><span style="color: rgb(30, 204, 255);">SpringBoot与logback日志</span>：</div><div>        常用的日志：</div><div>        log4j：出现较早，apach提供的比较完善的日志框架，庞大的日志框架，能输出到文件和控制台，没有实现slf4j。</div><div>        slf4j：简单的日志门面。</div><div>        logback：有更好的特性，实现了slf4j。</div><div>    1、导包：</div><div>  lombok</div><div>    添加lombok插件并配置logback-spring.xml文件，详看springboot文档</div><div><br/></div><div><br/></div><div>Springboot与servlet</div><div>        注解：</div><div>        @WebServlet：注解方式添加servlet，等同于在web.xml文件中注册</div><div>        @bean：添加在方法上的注释，相当于将返回值的对象作为类添加入bean容器中，bean对象的id为方法名</div><div>        在入口类添加注解@ServletComponentScan(basePackages=&quot;&quot;)</div><div><br/></div><div><br/></div><div>Springboot与filter过滤器</div><div>        注解：</div><div>        @Filter：</div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><span style="color: rgb(227, 0, 0);">nginx</span>服务器：</div><div>    三大功能：</div><div>        * 反向代理</div><div>        * 负载均衡</div><div>        * 动静分离</div><div><br/></div><div><br/></div><div><span style="color: rgb(255, 122, 116);">spingSecurity</span>：充分利用了spring的ioc和aop机制的声明式的安全访问框架，依赖于spring框架</div><div>    1、导包：</div><div>        spring-boot-starter-security：security包</div><div>    2、配置文件</div><div>        创建继承了WebSecurityConfigurerAdapter的配置类，实现config方法，AuthenticationManagerBuilder是spring框架提供的一个存放用户的对象。</div><div>        重写HttpSecurity参数的方法能自定义权限的拦截规则</div><div>            <span style="background-color: rgb(255, 255, 255); font-size: 8.4pt; color: rgb(0, 0, 0); font-family: 新宋体;">http.formLogin().successForwardUrl(</span><span style="background-color: rgb(255, 255, 255); font-size: 8.4pt; color: rgb(0, 128, 0); font-family: 新宋体; font-weight: bold;">&quot;&quot;</span><span style="font-size: 8.4pt; color: rgb(0, 0, 0); font-family: 新宋体;">).loginPage(&quot;&quot;)</span><span style="background-color: rgb(255, 255, 255); font-size: 8.4pt; color: rgb(0, 0, 0); font-family: 新宋体;">.loginProcessingUrl(</span><span style="background-color: rgb(255, 255, 255); font-size: 8.4pt; color: rgb(0, 128, 0); font-family: 新宋体; font-weight: bold;">&quot;&quot;</span><span style="font-size: 8.4pt; color: rgb(0, 0, 0); font-family: 新宋体;">)</span><span style="font-size: 8.4pt; color: rgb(0, 0, 0); font-family: 新宋体;">.usernameParameter(</span><span style="background-color: rgb(255, 255, 255); font-size: 8.4pt; color: rgb(0, 128, 0); font-family: 新宋体; font-weight: bold;">&quot;&quot;</span><span style="background-color: rgb(255, 255, 255); font-size: 8.4pt; color: rgb(0, 0, 0); font-family: 新宋体;">).passwordParameter(</span><span style="background-color: rgb(255, 255, 255); font-size: 8.4pt; color: rgb(0, 128, 0); font-family: 新宋体; font-weight: bold;">&quot;&quot;</span><span style="font-size: 8.4pt; color: rgb(0, 0, 0); font-family: 新宋体;">)</span><span style="font-size: 8.4pt; color: rgb(0, 0, 0); font-family: 新宋体;">.permitAll()</span><span style="font-size: 8.4pt; color: rgb(0, 0, 0); font-family: 新宋体;">;：</span><span style="font-size: 10pt; color: rgb(0, 0, 0);">登录成功跳转到该页面，自定义登录页面路径，用户名字段，密码字段</span></div><div><span style="font-size: 8.4pt; font-family: 新宋体;">     http.authorizeRequests().mvcMatchers(</span><span style="background-color: rgb(255, 255, 255); font-size: 8.4pt; color: rgb(0, 128, 0); font-family: 新宋体; font-weight: bold;">&quot;&quot;</span><span style="background-color: rgb(255, 255, 255); font-size: 8.4pt; font-family: 新宋体;">).hasAuthority(</span><span style="background-color: rgb(255, 255, 255); font-size: 8.4pt; color: rgb(0, 128, 0); font-family: 新宋体; font-weight: bold;">&quot;&quot;</span><span style="font-size: 8.4pt; font-family: 新宋体;">);</span><span style="font-size: unset; color: unset; font-family: unset;">：对某连接鉴定有无指定授权</span></div><div>            <span style="font-size: 8.4pt; color: rgb(0, 0, 0); font-family: 新宋体;">http.authorizeRequests().anyRequest().authenticated();</span><span style="font-size: 10pt; color: rgb(0, 0, 0);">放在最后一行，要求所有路径都要检查授权</span></div><div><span style="font-size: 10pt; color: rgb(0, 0, 0);">            </span><span style="background-color: rgb(255, 255, 255); font-size: 8.4pt; color: rgb(0, 0, 0); font-family: 新宋体;">web.ignoring().mvcMatchers(</span><span style="background-color: rgb(255, 255, 255); font-size: 8.4pt; color: rgb(0, 128, 0); font-family: 新宋体; font-weight: bold;">&quot;&quot;</span><span style="font-size: 8.4pt; color: rgb(0, 0, 0); font-family: 新宋体;">);</span><span style="font-size: 10pt; color: rgb(0, 0, 0);">对路径下静态资源放行</span></div><div>springSecurity禁止明文传输密码，需要将密码加密。需要将PasswordEncoder的实现类BCryptPasswordEncoder注册进bean，使用encode方法对密码进行加密。每次加密结果不一致，但能验证一致，所以安全。</div><div>        </div><div>        权限问题不跳转而是返回字符串：</div><div>            权限不足</div><div>                新建配置类，实现AccessDeniedHandler接口，重写handle方法，获取response将信息写入map中，使用response写json流。</div><div>                将这个配置类注入进上面配置类，http.exceptionHandling().accessDeniedHandler();使用这个方法解决权限不足</div><div>            登陆成功</div><div>                新建配置类，实现AuthenticationSuccessHandler接口，重写onAuthenticationSuccess方法，获取response，将auth对象写进map中，使用response写json流。</div><div>                将这个配置类注入进上方配置类，http.formLogin().successHandler(success).failureHandler(failure);</div><div>            登录失败</div><div>                新建配置类，实现AuthenticationFailureHandler接口，，重写onAuthenticationFailure方法，</div><div>                将这个配置类注入进上方配置类，http.formLogin().successHandler(success).failureHandler(failure);</div><div><br/></div><div>    <span style="color: rgb(227, 0, 0);">通过数据库查询用户权限</span></div><div>        在service层impl包里，添加类实现UserDetailsService接口，实现唯一方法，通过用户名从数据库查询用户信息。</div><div>        再查询出权限列表，将列表遍历，通过构造函数转变为SimpleGrantedAuthority类型，再收集为list。</div><div>        在Security主要配置类中，参数为AuthenticationManagerBuilder的config方法中依赖注入实现类，通过auth.userDetailsService();调用实例</div><div><br/></div><div>    @TableField(exist = false)：将实体类的之一字段剔除映射关系</div><div><br/></div><div>    3、注解形式对路径拦截授权：</div><div>        在配置方法上添加注解@EnableGlobalMethodSecurity(prePostEnabled = true)开启基于方法的权限验证</div><div>        在所需验证的接口上添加@PreAuthorize(&quot;hasAuthority('')&quot;)</div><div><br/></div><div>    4、跳转失败页面：</div><div>        在资源文件夹下，error/403.html文件，失败会自动跳至该页面</div><div><br/></div><div>    5、获取登陆者信息</div><div>        Principal类是jdk提供的登录信息规范接口，也可以在方法中接收这个对象，会自动填充用户信息，信息存在于security上下文中。</div><div><br/></div><div>    集成验证码：</div><div>        创建自定义过滤器，加入到security过滤器链前面。</div><div>        当验证码不通过时存入request域转发 异常 给验证码处理器，</div><div>        验证码处理器从request中取出后抛出。</div><div><br/></div><div>        创建类，在上面注解@ControllerAdvice，创建方法，在上面注解@ExceptionHandler(exception.class)：全局对抛出的指定异常进行捕获。</div><div><br/></div><div>        创建过滤器，集成OncePerRequestFilter，对每次请求过滤一次。</div><div>        <span style="background-color: rgb(255, 255, 255); font-size: 8.4pt; color: rgb(0, 0, 0); font-family: 新宋体;">http.addFilterAfter(, UsernamePasswordAuthenticationFilter.</span><span style="background-color: rgb(255, 255, 255); font-size: 8.4pt; color: rgb(0, 0, 128); font-family: 新宋体; font-weight: bold;">class</span><span style="font-size: 8.4pt; color: rgb(0, 0, 0); font-family: 新宋体;">);</span><span style="font-size: 10pt; color: rgb(0, 0, 0);">在security主配置类中写，过滤器链前添加自己的过滤器实体。</span></div><div><br/></div><div><br/></div><div>    过滤器链：</div><div>        UsernamePasswordAuthentication</div><div><br/></div><div><br/></div><div>    <span style="color: rgb(227, 0, 0);">jwt</span>:    json wen token 令牌，适用于单点登录，生成唯一且可以解析出来的json字符串，创建令牌的一种方式</div><div>        1、导包</div><div>            java-jwt</div><div>        2、使用</div><div>            JWT.create.withHeade(map).withClaim(&quot;key&quot;,&quot;value&quot;).withExporesAt(过期时间).withIssuedAt(发布时间).sign(签名)；：生成</div><div>            DecodeJWT verify= JWT.require(签名).build().verify(jwt);verify.getClaim();解析获取信息</div><div>        </div><div>        </div><div><br/></div><div>    常见的保持会话的机制：</div><div>        session：</div><div>            无法跨服务器，需要把nginx改成IP绑定服务器才能解决。</div><div>            或者将session存入数据库</div><div>        token：令牌</div><div>            服务端生成token给客户端存在cookie中，服务端通过验证后即可确认用户信息</div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><span style="color: rgb(227, 0, 0);">RabbitMQ</span>：消息队列系统</div><div>    拥有事务机制，保证多条消息同时成功或失败</div><div>    特点：</div><div>        可靠性：持久化，传输确认，发布确认</div><div>        灵活的路由：Exchange</div><div>        消息集群：多个服务器组成集群</div><div>        高可用：对了可在集群上镜像，部分节点出问题的情况下仍可用</div><div>        跟踪机制：提供了消息跟踪机制</div><div>        有管理界面：</div><div><br/></div><div>    三要素：</div><div>        Exchanges：消息交换机，指定按照什么规则路由到那个队列</div><div>        Queues：消息队列，先进先出，每个喜爱西会投放至一个或多个队列</div><div>        Bindings：绑定器，将交换机和队列按照规则绑定起来</div><div><br/></div><div>    关键字：</div><div>        Routing Key：路由关键字，交换机根据关键字将消息分发给队列</div><div>        Connection：TCP链接，消费者与发送者通过Connection链接RabbitMQ</div><div>        Channel：管道，创建于Connection，数据通过管道进行传递</div><div><br/></div><div>    工作模式：</div><div>        简单模式：一对一发送消费</div><div>        竞争消费者模式：一生产多消费的模式，仅一个能抢到消息。</div><div>        发布、订阅模式：生产者将消息发送到交换机，交换机根据规则将消息投放至队列。</div><div>        路由模式：生产者将消息发送给路由，并生成key，根据key送到响应队列，监听该队列的信息消费</div><div>        主题模式：根据routing_key匹配队列，将消息发送给多个队列</div><div><br/></div><div>    RabbitMQ确认消息：</div><div><br/></div><div>    消息消费确认：</div><div><span style="font-size: unset;"><br/></span></div><div><span style="font-size: unset; color: unset; font-family: unset;">    消息补偿机制：</span></div><div><span style="font-size: unset; color: unset; font-family: unset;">        </span>生产消息检测消息</div><div>            生产者将信道设置成confirm模式，所有在该信道上面发布的消息都会被指派一个唯一的ID，路由就会发送一个带ID消息的确认给生产者，为了producer端知道消息是否进入queue，可以使用confirm和return来代替事务。</div><div>            1、确认是否到达交换器</div><div>            2、确认是否到达队列</div><div>        补偿方案：</div><div>            在rabbitTemplate异步确认的基础上，<span style="font-size: unset; color: unset; font-family: unset;">在本地缓存已发送的message，</span><span style="font-size: unset; color: unset; font-family: unset;">通过confirmCallback或者被确认的</span><span style="font-size: unset;"><span style="font-size: unset; color: rgb(250, 122, 0); font-family: unset;">ack</span></span><span style="font-size: unset; color: unset; font-family: unset;">，将被确认的message从本地删除，</span><span style="font-size: unset; color: unset; font-family: unset;">定时扫描本地的message，如果大于一定时间未被确认，则重发</span></div><div><span style="font-size: unset;"><br/></span></div><div><span style="font-size: unset; color: unset; font-family: unset;">    </span>什么是死信队列：</div><div>        由于特定的原因导致队列中的某些消息无法被消费，这样的消息如果没有后续的处理，就变成了死信(Dead Letter)，所有的死信都会放到死信队列中。</div><div><br/></div><div><br/></div><div><br/></div><div><span style="color: rgb(227, 0, 0);">springCloud</span>：微服务框架依赖于SpringBoot框架</div><div>    与springboot不同，springboot是简化配置，springcloud是微服务框架，springcloud不能独立运行，需要依赖于springboot</div><div>    与RPC框架不同，采用的是每个功能都是完整的，从控制器到数据库连接都是包含的，RPC采用的是远程过程调用方式引用service层，需要<span style="font-size: unset; color: unset; font-family: unset;">注入service层对象。springCloud采用的是http方式进行远程调用，需要自动注入RestTemplate，调用 RestTemplate对象发送请求，不需要service层对象。</span></div><div>    1、导包</div><div>        将打包方式packaging改为pom</div><div>        导入springcloud依赖包：spring-cloud-dependencies</div><div>        导入springboot依赖包：spring-boot-dependencies</div><div>    2、配置</div><div>    重写RestTemplate获取：</div><div>        在@configuration类中添加@bean</div><div>        public RestTemplate getRestTemplate(){ return new RestTemplate(); }</div><div><br/></div><div>     RestTemplate只接受restfull风格的请求</div><div>        调用RestTemplate.postForObject进行访问</div><div>    </div><div>    springCloud启动插件：</div><div>        spring-cloud-start</div><div><br/></div><div><br/></div><div><span style="color: rgb(227, 0, 0);">Eureka</span>：与zookeeper相同是服务注册与发现，不同的是zookeeper是软件包，而Eureka是需要手动实现服务。</div><div>    和zookeeper相同点</div><div>        有心跳机制，30s注册一次，但失联后不注销，自我保护机制好死不如赖活着，可以设置eureka.server.enable-self-preservation=false关闭（不推荐）</div><div><br/></div><div>CAP是非关系型数据库追求特性：</div><div>    强一致性、可用性、分区容错性</div><div>    zookeeper保证强一致性，分区容错性，master宕掉后，leader会选举出新master，但选举时间长</div><div>    Eureka保证可用性，分区容错性，所有节点都是平等的</div><div><br/></div><div>    1、创建模块包，</div><div>        导入Eureka的spring-cloud-starter-eurekc-server包，</div><div>    2、配置文件：</div><div>                server:</div><div>                    port:对应端口号</div><div>                eureka:</div><div>                    instance:</div><div>                        hostname:实例化后的名字如eu</div><div>                    client:</div><div>                        regoster-with-eureka:是否向eureka注册中心注册自己——注册中心与消费者为false</div><div>                        fetch-registry:是否从注册中心拉去注册——注册中心为false</div><div>                        service-url:</div><div>                            defaultZone:http://${eureka.instance.hostname}:${server.port}/eureka     #监控页面，其它端填写服务机地址。    Eureka集群多注册中心，写其它注册中心地址，以','分隔。消费者与生产者写所有的服务机地址</div><div>                    instance:</div><div>                        instance-id:    监控面板中显示的名称</div><div>                        prefer-ip-adress:    监控面板上的连接显示真实IP</div><div>    3、创建启动类，添加注解开启服务</div><div>                        @springBootApplication：表示是spring boot项目</div><div>                        @EnableEurekaServer：开启Eureka注册服务</div><div>                        @EnableEurekaClient：开启Eureka客户端</div><div>    在客户端可以导入spring-boot-starter-actuator包完善监控信息，并在配置文件中完善。   </div><div>                info:</div><div>                    app.name:</div><div>                    company.name:公司名</div><div>    在监控页面中点击该服务会以json字符串形式返回以上信息。</div><div><br/></div><div><br/></div><div><span style="color: rgb(227, 0, 0);">Ribbon</span>：是实现客户端负载均衡的工具，将用户请求平摊到多个服务器上，进程式负载均衡(LB)，集成在消费端</div><div>    1、消费者导包</div><div>        spring-cloud-starter-ribbon</div><div>    2、添加注解</div><div>        消费者使用RestTemplate访问服务，所以在RestTemplate获取上添加@LoadBalanced</div><div>    Ribbon会从配置中读取Eureka注册中心配置，通过http请求找到对应的eureka.instance.hostname查找服务者</div><div><br/></div><div>负载均衡策略，有过滤跳闸的再轮询，随机，权重机制，先轮询失败后重试</div><div><br/></div><div><span style="color: rgb(227, 0, 0);">Feign</span>：web service客户端，类似于controller调用service，面向接口。spring cloud集成了Ribbon和Eureka，Feign集成了Ribbon，实际仍未Ribbon。</div><div>    1、导包</div><div>        公共模组导包spring-cloud-starter-feign</div><div>    2、添加注解</div><div>        在公共模组添加service层，service层接口上，添加@FeignClient(value = &quot;eureka.instance.hostname&quot;)</div><div>        在消费者启动类添加扫描注解@EnableFeginClients(basePackages = {&quot;包名&quot;})，@ComponentScan(&quot;包名&quot;)</div><div>    </div><div>    使用：消费者模组中，注入service对象，并调用其中的方法</div><div><br/></div><div><span style="color: rgb(227, 0, 0);">Nginx</span>：是实现客户端负载均衡的工具，将用户请求平摊到多个服务器上，反向代理服务器，集中式负载均衡，独立的负载均衡(LB)设施</div><div><br/></div><div>                </div><div><span style="color: rgb(227, 0, 0);">Hystrix</span>：服务熔断，在服务端实现，保证在一个服务调用失败的时候不会导致整体失败避免系统崩溃，环节中某个服务崩溃或响应时间过长时，替换成备选响应或停止扇出链路。服务熔断：扇出链路中某个服务崩溃或响应时间过长时，会对该服务降级，进而熔断该节点的调用。</div><div>    1、导包</div><div>        spring-cloud-starter-hystrix</div><div>    2、添加注解</div><div>        在服务者控制器那里，添加备用方法，在调用方法上添加注解@HystrixCommand(fallbackMethod = &quot;备用方法名&quot;)</div><div>        在启动方法上添加@EnableCircuitBreaker注解来支持熔断机制</div><div>    服务降级：在客户端实现</div><div>        1、在公共模块添加FallBackFactory接口的实现类，重写create方法，返回service（与Feign相关联）类对象，或service接口的实现类对象，在同名方法中返回一个默认值</div><div>        2、给启动类注解中添加备用类@FeignClient(value = &quot;eureka.instance.hostname&quot;)</div><div>        3、在消费者配置文件中添加feign.hystrix.enabled:true</div><div>    </div><div>    dashboard：流监控</div><div>    1、导包</div><div>         新建空白模组，导入spring-cloud-starter-hystrix-dashboard包</div><div>    2、添加注解</div><div>        空白模组启动类添加注解@EnableFystrixDashboard</div><div>    3、服务端完善监控信息</div><div>                服务端导入spring-cloud-starter-actuator包，在服务端的启动类中添加固定的@bean方法</div><div><br/></div><div><br/></div><div><span style="color: rgb(227, 0, 0);">Zuul</span>：路由网关，对请求进行路由和过滤，外部请求的同一入口，需要与Eureka进行整合，Zuul自身注册为Eureka治理下的应用，访问其它的服务</div><div>    1、导包</div><div>        新建空白模组，导入Eureka包和Zuul包spring-cloud-starter-zuul</div><div>    2、添加注解与配置</div><div>        在配置文件中给模组命名：spring.application.name: </div><div>        添加注册中心地址eureka.client.service-url.defaultZone:</div><div>        在zuul配置文件中添加</div><div>            zuul:</div><div>                routes:</div><div>                    mydept.serverId:服务id</div><div>                    mydept.path:路径规则</div><div>                ignored-services:禁止访问这个的路径</div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div></span>
</div></body></html> 